#+TITLE: Emacs Configuration
#+AUTHOR: Nicholas Coughlin
#+EMAIL: nicocoffo@gmail.com

#+NAME: Note
#+BEGIN_SRC emacs-lisp
  ;;; ------------------------------------------
  ;;; Do not edit this file. It was tangled from
  ;;; an org file.
  ;;; ------------------------------------------
#+END_SRC

* Package Management with Pallet
  Stole all of this from [[https://github.com/Errorific/dotfiles][Errorific]] cause its cool. I would use something similar for all confs,
  if I had the effort + time available.

  Saltstack will manage all the Cask + Pellet stuff, installing Cask and providing a minimal Caskfile to get things going. This file is then tangled
  and used to configure emacs. I think.

* Dependency Management with =req-package=
  [[https://github.com/edvorg/req-package][req-package]] is a wrapper on top of [[https://github.com/jwiegley/use-package][use-package]], a package dependency
  management tool. The documentation for =use-package= is immensely helpful for figuring out how to describe package dependencies and settings. =req-package=
  adds the =:require= keyword which allows us to define dependencies between related packages.

  #+BEGIN_SRC emacs-lisp
    (require 'req-package)
    (setq custom-file "~/.emacs.d/custom.el")
    (load custom-file)
  #+END_SRC

* Keybindings with =bind-key=
  There are a number of ways to bind keys in Emacs, but I find
  =bind-key=, bundled with =use-package=, easier to work with and,
  more importantly, easier to read. =bind-key= takes a key sequence, a
  command, and an optional keymap.  =bind-key*= overrides any minor
  mode which sets the keybinding. =unbind-key= takes a key sequence
  and a keymap and removes that binding. Invoking
  =describe-personal-keybindings= prints a summary of your keybindings
  through =bind-key= and any overrides or conflicts. This is really
  THE killer convenience of using =bind-key=.

* =evil=
  Here we have our first package with dependencies. Historically, I've had
  little annoyances when =evil= loads before =evil-leader=, so we'll make sure
  it gets loaded first. By default, =evil= uses its own cursor which shows up
  black regardless of face settings. Setting =evil-default-cursor= lets us use
  the cursor we're used to. I also redefine a couple of =ex= commands for
  convenience.

  #+BEGIN_SRC emacs-lisp
    (req-package evil
      :require (undo-tree ace-jump-mode)
      :init
      (progn
        (setq evil-default-cursor t)
        (evil-mode 1)
        (setq evil-motion-state-modes
              (append evil-emacs-state-modes evil-motion-state-modes))
        (setq evil-emacs-state-modes
          '(magit-mode
            magit-commit-mode
            magit-log-mode
            magit-status-mode
            magit-stash-mode
            git-status-mode
            grep-mode
            dired-mode)))
      :config
      (progn
        (bind-key "[escape]" 'keyboard-escape-quit evil-normal-state-map)
        (bind-key "[escape]" 'keyboard-escape-quit evil-visual-state-map)
        (bind-key "<escape>" 'keyboard-escape-quit)
        (bind-key "\"" 'ace-jump-mode evil-normal-state-map)
        (evil-define-key 'normal
                         tern-mode-keymap "gd" 'tern-find-definition)))
  #+END_SRC

** =evil-leader=
   =<leader>= is a really useful shorthand in Vim, and [[https://github.com/cofi/evil-leader][evil-leader]] brings the
   same facility to Evil. For really common commands, leader bindings can save
   those precious keystrokes.

   #+BEGIN_SRC emacs-lisp
     (req-package evil-leader
                  :require (evil evil-nerd-commenter smex function-args)
                  :ensure evil-leader
                  :init
                  (progn
                    (evil-leader/set-leader "<SPC>")
                    (global-evil-leader-mode 1)
                    (evil-leader/set-key
                      "a" 'projectile-ag
                      "l" 'org-insert-link
                      "o" 'other-window
                      "d" 'delete-window
                      "D" 'delete-other-windows
                      "h" 'split-window-below
                      "v" 'split-window-right
                      "k" 'kill-buffer
                      "K" 'kill-buffer-and-window
                      "f" 'ido-find-file
                      "c" 'evilnc-comment-or-uncomment-lines
                      "n" 'flycheck-next-error
                      "p" 'flycheck-previous-error
                      "x" 'smex
                      "gs" 'magit-status)
                    (evil-leader/set-key-for-mode 'haskell-mode
                      "?" 'ghc-display-errors)))
   #+END_SRC

** =evil-surround=
   Working with delimiter pairs is common enough that Tim Pope wrote a plugin
   to ease working with them in Vim, called [[https://github.com/tpope/vim-surround][vim-surround]]. [[https://github.com/timcharper/evil-surround][evil-surround]]
   emulates this functionality in =evil=. It's quite extensible, but the
   defaults seem to cover all my needs. Check out the README for some examples.

   #+BEGIN_SRC emacs-lisp
     (req-package evil-surround
                  :require evil
                  :init (global-evil-surround-mode 1))
   #+END_SRC

** =evil-matchit=
   Allows you to use % to jump between matched tags in html etc instead of
   just matched delimters

   #+BEGIN_SRC emacs-lisp
     (req-package evil-matchit
                  :require (evil tt-mode)
                  :init (global-evil-matchit-mode 1)
                  :config (
                    plist-put evilmi-plugins 'tt-mode '(
                      (evilmi-simple-get-tag evilmi-simple-jump)
                      (evilmi-html-get-tag evilmi-html-jump))))
   #+END_SRC

** =undo-tree=
   Standard Emacs undo is kind of confusing. [[http://www.dr-qubit.org/emacs.php#undo-tree][undo-tree]] replaces this with a
   simpler tree structure. It also allows us to visualize the tree directly.

   #+BEGIN_SRC emacs-lisp
     (req-package undo-tree
                  :diminish ""
                  :init
                  (progn
                    (setq undo-tree-auto-save-history t)
                    (global-undo-tree-mode)
                    (setq undo-tree-history-directory-alist
                      (quote (("." . "~/.emacs.d/undo/"))))))
   #+END_SRC

** =ace-jump-mode=
   Numbers words starting with a search letter then jumps to the selected. Amazing. Mapped to ".

   #+BEGIN_SRC emacs-lisp
     (req-package ace-jump-mode)
   #+END_SRC

** =evil-nerd-commenter=
   Comment and uncomment. Mapped to <SPC>-c for toggle.

    #+BEGIN_SRC emacs-lisp
      (req-package evil-nerd-commenter
        :require evil)
    #+END_SRC

* Projectile
  Projectile gives a nice way of navigating projects, and finding files, and
  all kinds of things.

  #+BEGIN_SRC emacs-lisp
    (req-package projectile
       :init (projectile-global-mode))
  #+END_SRC

* Org
  #+BEGIN_SRC emacs-lisp
    (req-package org
      :config
      (progn
        (add-hook 'org-mode-hook
                  '(lambda ()
                     (setq mode-name " ꙮ ")))
        (bind-key* "C-c c" 'org-capture)
        (bind-key* "C-c l" 'org-store-link)
        (bind-key* "C-c a" 'org-agenda)
        (bind-key* "C-c b" 'org-iswitch)))
  #+END_SRC

* UI

** flxIdo
   Ido has turned out to be pretty awesome, but it gets significantly better
   with fuzzy matching

   #+BEGIN_SRC emacs-lisp
     (req-package flx-ido
        :require flx
        :init (progn
          (ido-mode 1)
          (ido-everywhere 1)
          (flx-ido-mode 1)))
   #+END_SRC

** Theme
   I like having the same colours in both terminal and emacs, so I define some selection of base16
   colours in iterm and configure various things in emacs, based on the 16 terminal colours.

   #+BEGIN_SRC emacs-lisp
     (defadvice load-theme
       (before theme-dont-propagate activate)
       (mapc #'disable-theme custom-enabled-themes))

     (load-theme 'base16-terminal :no-confirm)
   #+END_SRC

** Powerline
   My horrible attempt at powerline in terminal emacs. A weird merge of [[https://github.com/raugturi/powerline-evil][powerline-evil]] and [[https://github.com/unic0rn/powerline][utf-8 powerline]]

   #+BEGIN_SRC emacs-lisp
     (add-to-list 'load-path "~/.emacs.d/powerline")
     (require 'powerline)
     (powerline-evil-vim-color-theme)
   #+END_SRC

** Faces
   #+BEGIN_SRC emacs-lisp
     (req-package faces
                  :config
                  (progn
                    (set-face-attribute 'default nil :family "Source Code Pro")
                    (set-face-attribute 'default nil :height 100)))
   #+END_SRC

** 80+ Lines
   Uni really doesn't like 80+ lines

   #+BEGIN_SRC emacs-lisp
     (req-package column-enforce-mode
       :config (add-hook 'prog-mode-hook 'column-enforce-mode) )
   #+END_SRC

** Cleanup
   Who wants all that toolbars and scrollbars noise?

   #+BEGIN_SRC emacs-lisp
     (req-package scroll-bar
                  :config
                  (scroll-bar-mode -1))

     (req-package tool-bar
                  :config
                  (tool-bar-mode -1))

     (req-package menu-bar
                  :config
                  (menu-bar-mode -1))
   #+END_SRC

* IDE
  A few conveniences that I like to have in all my =prog-mode= buffers.

** Flycheck
   Flycheck has helped me write more programs than I'm totally
   comfortable admitting.

   #+BEGIN_SRC emacs-lisp
     (req-package flycheck
       :diminish (global-flycheck-mode . " ✓ ")
       :config (progn
         (add-hook 'after-init-hook 'global-flycheck-mode)))
   #+END_SRC

** Magit
   The only git wrapper that matters.

   #+BEGIN_SRC emacs-lisp
     (req-package magit
       :diminish magit-auto-revert-mode)
   #+END_SRC

** Line Numbers
   #+BEGIN_SRC emacs-lisp
     (req-package linum
       :config (progn
         (add-hook 'html-mode-hook
                   '(lambda () (linum-mode 1)))
         (add-hook 'tt-mode-hook
                   '(lambda () (linum-mode 1)))
         (add-hook 'cperl-mode-hook
                   '(lambda () (linum-mode 1)))
         (add-hook 'prog-mode-hook
                   '(lambda () (linum-mode 1))
                   '(lambda () (column-number-mode 1)))
         (defun nolinum () (linum-mode 0))
         (add-hook 'org-mode-hook 'nolinum)
         (add-hook 'project-explorer-mode-hook 'nolinum)
         (add-hook 'term-mode-hook 'nolinum)
         (add-hook 'magit-mode-hook 'nolinum)
         (setq linum-format "%4d\u2502")))
   #+END_SRC

** Smex
   #+BEGIN_SRC emacs-lisp
     (req-package smex)
   #+END_SRC

** Delimiters
   I like my delimiters matched and visually distinct. I used [[https://bitbucket.org/kovisoft/paredit][paredit]] for a
   long time, but I'm currently experimenting with [[https://github.com/Fuco1/smartparens][smartparens]]. As for the
   visual element, I quite like [[https://github.com/jlr/rainbow-delimiters][rainbow-delimiters]].

   #+BEGIN_SRC emacs-lisp
     (req-package smartparens-config
       :ensure smartparens
       :diminish (smartparens-mode . "()")
       :init (smartparens-global-mode t))

     (req-package rainbow-delimiters
       :config
       (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))
   #+END_SRC

** Colors
   I've had to work with colors in a fair bit of code, so having them displayed
   in buffer is convenient.

   #+BEGIN_SRC emacs-lisp
     (req-package rainbow-mode
       :diminish (rainbow-mode . "")
       :config (add-hook 'prog-mode-hook 'rainbow-mode))
   #+END_SRC

** Completion
   #+BEGIN_SRC emacs-lisp
     (req-package auto-complete-config
       :require (ac-math)
       :ensure auto-complete
       :init
       (progn
         (ac-config-default)
         (setq ac-auto-start 3))
       :config
       (progn
         (require 'ac-math)))
   #+END_SRC

** Tags
   #+BEGIN_SRC emacs-lisp
     (req-package ggtags)
   #+END_SRC

** Ag
   Support for the ag tool for doing file searching

   #+BEGIN_SRC emacs-lisp
     (req-package ag
       :config (progn
         (setq ag-highlight-search t)
       )
     )
   #+END_SRC

* Behaviour

** Indentation
   Hell is tabs

   #+BEGIN_SRC emacs-lisp
     (setq-default indent-tabs-mode nil)
     (setq tab-width 2) ; or any other preferred value
   #+END_SRC

** UTF8
   #+BEGIN_SRC emacs-lisp
     (setq locale-coding-system 'utf-8)
     (set-terminal-coding-system 'utf-8)
     (set-keyboard-coding-system 'utf-8)
     (set-selection-coding-system 'utf-8)
     (prefer-coding-system 'utf-8)
   #+END_SRC

** Refresh buffers
   Files that change on disk should chage their buffers

   #+BEGIN_SRC emacs-lisp
     (global-auto-revert-mode 1)
   #+END_SRC

   and dired

   #+BEGIN_SRC emacs-lisp
     (setq global-auto-revert-non-file-buffers t)
     (setq auto-revert-verbose nil)
   #+END_SRC

** Whitespaces
   Show trailing and delete them on save

   #+BEGIN_SRC emacs-lisp
     (setq-default show-trailing-whitespace t)
     (add-hook 'before-save-hook 'whitespace-cleanup)
   #+END_SRC

* OSX
  Things that need changing on macs

** Mac keys
   Switch the Cmd and Meta keys

   #+BEGIN_SRC emacs-lisp
     (setq mac-option-key-is-meta nil)
     (setq mac-command-key-is-meta t)
     (setq mac-command-modifier 'meta)
     (setq mac-option-modifier nil)
   #+END_SRC

** Default browser
   Make it match the system setting

   #+BEGIN_SRC emacs-lisp
     (setq browse-url-browser-function 'browse-url-default-macosx-browser)
   #+END_SRC

** Delete to trash
   #+BEGIN_SRC emacs-lisp
     (setq delete-by-moving-to-trash t)
   #+END_SRC

* Languages
** C
   #+BEGIN_SRC emacs-lisp
     (setq-default c-basic-offset 4)
     (setq-default c-default-style "linux")
     (defun c-indent-setup ()
       (c-set-offset 'arglist-cont-nonempty '++)
       (c-set-offset 'case-label '+))
     (add-hook 'c-mode-hook 'c-indent-setup)
     (define-key evil-insert-state-map (kbd "RET") 'newline-and-indent)
   #+END_SRC

** YAML
   #+BEGIN_SRC emacs-lisp
     (req-package yaml-mode
       :require (flycheck)
       :init (add-to-list 'auto-mode-alist '("\\.ya?ml$" . yaml-mode))
     )
   #+END_SRC

* Annoyances
  Fixing a couple of gripes I have with Emacs.

** Startup screen
   wtf is this uneditable bs

   #+BEGIN_SRC emacs-lisp
   (setq inhibit-startup-screen t)
   #+END_SRC

** Exec path
   This makes your emacs exec path match what a shell does from your
   current environment. For various reasons my shell isn't my default
   so this doesn't work, I get around it by hacking together a shortcut
   to emacs that its run under my zsh profile. Most places this is
   block is what you want instead.

   #+BEGIN_SRC emacs-lisp
     (req-package exec-path-from-shell
       :init
       (when (memq window-system '(mac ns))
         (exec-path-from-shell-initialize)))
   #+END_SRC

** Backups and Autosave Files
   These things end up everywhere, so let's stick them all in a temporary
   directory.

   #+BEGIN_SRC emacs-lisp
     (req-package files
       :init
       (progn
         (setq backup-directory-alist
               `((".*" . ,temporary-file-directory)))
         (setq auto-save-file-name-transforms
               `((".*" ,temporary-file-directory t)))))
   #+END_SRC

** Questions
   Keep it short.

   #+BEGIN_SRC emacs-lisp
     (defalias 'yes-or-no-p 'y-or-n-p)
   #+END_SRC

** Customizations
   [[http://www.emacswiki.org/emacs/cus-edit%2B.el][cus-edit+]] is a really handy way to keep your customizations up to
   date, especially if you set your =custom-file=.

   #+BEGIN_SRC emacs-lisp
     (req-package cus-edit+
       :init (customize-toggle-outside-change-updates))
   #+END_SRC
* Fulfill Requirements
  At long last we need only call the following function to send =req-package= on
  its merry way.

  #+BEGIN_SRC emacs-lisp
    (req-package-finish)
  #+END_SRC
